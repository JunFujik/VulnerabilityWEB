from sqlalchemy_utils import UUIDType, EmailType, PasswordType, force_auto_coercion, JSONType, escape_like
from sqlalchemy.orm import relationship, joinedload, selectinload
from sqlalchemy import Column, Boolean, Unicode, DateTime, Integer, ForeignKey, Float
from sqlalchemy import update as sqlalchemy_update
from sqlalchemy import delete as sqlalchemy_delete
from sqlalchemy.future import select
import uuid
from datetime import datetime
from ..db import Base, db
from pydantic import SecretStr
from ..exceptions.user import TokenNotFound, Forbidden

force_auto_coercion()

class User(Base):
    __tablename__ = "users"

    id = Column(UUIDType(binary=False), primary_key=True, default=uuid.uuid4, unique=True)
    name = Column(Unicode(1024), nullable=False)
    email = Column(EmailType(1024), unique=True, nullable=False)
    password = Column(PasswordType(max_length=1024, schemes=['pbkdf2_sha512','md5_crypt'],deprecated=['md5_crypt']), nullable=True)
    is_store = Column(Boolean(), default=False, nullable=False)
    created_at = Column(DateTime, index=True, default=datetime.utcnow)
    icon=Column(Unicode(1024), default=None)

    tokens = relationship("Token", back_populates="user")
    shops = relationship("Shop", back_populates="user")

    @classmethod
    async def create(cls, **kwargs):
        if isinstance(kwargs.get("password", None), SecretStr):
            kwargs["password"]=kwargs["password"].get_secret_value()
        user = cls(**kwargs)
        db.add(user)
        try:
            await db.commit()
        except Exception:
            await db.rollback()
            raise
        return user
    @classmethod
    async def update(cls, id, **kwargs):
        query = (
            sqlalchemy_update(cls)
            .where(cls.id == id)
            .values(**kwargs)
            .execution_options(synchronize_session="fetch")
        )
        await db.execute(query)
        try:
            await db.commit()
        except Exception:
            await db.rollback()
            raise
    @classmethod
    async def get(cls, id, include_tokens=False, include_shops=False):
        query = select(cls).where(cls.id == id)
        if include_tokens:
            query=query.options(selectinload(cls.tokens))
        if include_shops:
            query=query.options(selectinload(cls.shops))
        users = await db.execute(query)
        user=users.first()
        return (user[0] if user is not None else None)
    @classmethod
    async def get_bymail(cls, mail, include_tokens=False, include_shops=False):
        query = select(cls).where(cls.email == mail)
        if include_tokens:
            query=query.options(selectinload(cls.tokens))
        if include_shops:
            query=query.options(selectinload(cls.shops))
        users = await db.execute(query)
        user = users.first()
        return (user[0] if user is not None else None)
    @classmethod
    async def delete(cls, id):
        user_obj=await cls.get(id, include_shops=True, include_tokens=True)
        for token in user_obj.tokens:
            await Token.delete(token.token)
        for shop in user_obj.shops:
            await Shop.delete(shop.id)
        query = sqlalchemy_delete(cls).where(cls.id == id)
        await db.execute(query)
        try:
            await db.commit()
        except Exception:
            await db.rollback()
            raise
        return True

class Token(Base):
    __tablename__="tokens"

    token = Column(UUIDType(binary=False), default=uuid.uuid4, unique=True, primary_key=True)
    created_at = Column(DateTime, index=True, default=datetime.utcnow)
    user_id = Column(UUIDType(binary=False), ForeignKey('users.id'))
    expired_in = Column(DateTime, index=True, default=datetime.utcnow)

    user = relationship("User", back_populates="tokens")

    @classmethod
    async def create(cls, **kwargs):
        token = cls(**kwargs)
        db.add(token)
        try:
            await db.commit()
        except Exception:
            await db.rollback()
            raise
        return token
    @classmethod
    async def update(cls, token, **kwargs):
        query = (
            sqlalchemy_update(cls)
            .where(cls.token == token)
            .values(**kwargs)
            .execution_options(synchronize_session="fetch")
        )
        await db.execute(query)
        try:
            await db.commit()
        except Exception:
            await db.rollback()
            raise
    @classmethod
    async def get(cls, token):
        query = select(cls).where(cls.token == token).options(joinedload(cls.user))
        tokens = await db.execute(query)
        token_obj=tokens.first()
        return (token_obj[0] if token_obj is not None else None)
    @classmethod
    async def check(cls, id, token):
        query = select(cls).where(cls.token == token).options(joinedload(cls.user))
        tokens = await db.execute(query)
        token_obj=tokens.first()
        if token_obj is None:
            raise TokenNotFound(id, token)
        elif str(id) !=str(token_obj[0].user_id):
            raise Forbidden(description="Token is not yours.")
        elif token_obj[0].expired_in < datetime.utcnow():
            try:
                await cls.delete(token)
            finally:
                raise Forbidden(description="Token was already expired.")
        else:
            return token_obj[0]
    @classmethod
    async def delete(cls, token):
        token_obj=await cls.get(token)
        token_obj.user=None
        query = sqlalchemy_delete(cls).where(cls.token == token)
        await db.execute(query)
        try:
            await db.commit()
        except Exception:
            await db.rollback()
            raise
        return True

class Shop(Base):
    __tablename__="shops"

    id=Column(UUIDType(binary=False), default=uuid.uuid4, unique=True, primary_key=True)
    name=Column(Unicode(1024), nullable=False)
    description=Column(Unicode(1024), nullable=False)
    user_id=Column(UUIDType(binary=False), ForeignKey('users.id'))
    address=Column(Unicode(1024), nullable=False)
    map=Column(Unicode(1024), default=None)
    icon=Column(Unicode(1024), default=None)
    coordinate=Column(JSONType, nullable=False)

    user = relationship("User", back_populates="shops")
    items = relationship("Item", back_populates="shop")

    @classmethod
    async def create(cls, **kwargs):
        shop = cls(**kwargs)
        db.add(shop)
        try:
            await db.commit()
        except Exception:
            await db.rollback()
            raise
        return shop
    @classmethod
    async def update(cls, id, **kwargs):
        query = (
            sqlalchemy_update(cls)
            .where(cls.id == id)
            .values(**kwargs)
            .execution_options(synchronize_session="fetch")
        )
        await db.execute(query)
        try:
            await db.commit()
        except Exception:
            await db.rollback()
            raise
    @classmethod
    async def get(cls, id, include_items=False):
        query = select(cls).where(cls.id == id).options(joinedload(cls.user))
        if include_items:
            query=query.options(selectinload(cls.items))
        shops = await db.execute(query)
        shop_obj=shops.first()
        return (shop_obj[0] if shop_obj is not None else None)
    @classmethod
    async def search_byaddress(cls, address, include_items=False):
        query = select(cls).filter(cls.address.like(f"%{escape_like(address)}%")).options(joinedload(cls.user))
        if include_items:
            query=query.options(selectinload(cls.items))
        shops = await db.execute(query)
        shop_obj=shops.all()
        return [shop[0] for shop in shop_obj]
    @classmethod
    async def delete(cls, id):
        shop_obj=await cls.get(id, include_items=True)
        for item in shop_obj.items:
            await Item.delete(item.id)
        shop_obj.user=None
        query = sqlalchemy_delete(cls).where(cls.id == id)
        await db.execute(query)
        try:
            await db.commit()
        except Exception:
            await db.rollback()
            raise
        return True

class Item(Base):
    __tablename__="items"

    id=Column(UUIDType(binary=False), default=uuid.uuid4, unique=True, primary_key=True)
    name=Column(Unicode(1024), nullable=False)
    description=Column(Unicode(1024), nullable=False)
    stock=Column(JSONType, nullable=False)
    shop_id=Column(UUIDType(binary=False), ForeignKey('shops.id'))
    icon=Column(Unicode(1024), default=None)

    shop=relationship("Shop", back_populates="items")

    @classmethod
    async def create(cls, **kwargs):
        item = cls(**kwargs)
        db.add(item)
        try:
            await db.commit()
        except Exception:
            await db.rollback()
            raise
        return item
    @classmethod
    async def update(cls, id, **kwargs):
        query = (
            sqlalchemy_update(cls)
            .where(cls.id == id)
            .values(**kwargs)
            .execution_options(synchronize_session="fetch")
        )
        await db.execute(query)
        try:
            await db.commit()
        except Exception:
            await db.rollback()
            raise
    @classmethod
    async def get(cls, id):
        query = select(cls).where(cls.id == id).options(joinedload(cls.shop))
        items = await db.execute(query)
        item_obj=items.first()
        return (item_obj[0] if item_obj is not None else None)
    @classmethod
    async def search_byname(cls, name):
        query = select(cls).filter(cls.name.like(f"%{escape_like(name)}%")).options(joinedload(cls.shop))
        items = await db.execute(query)
        item_obj=items.all()
        return [item[0] for item in item_obj]
    @classmethod
    async def delete(cls, id):
        item_obj=await cls.get(id)
        item_obj.shop=None
        query = sqlalchemy_delete(cls).where(cls.id == id)
        await db.execute(query)
        try:
            await db.commit()
        except Exception:
            await db.rollback()
            raise
        return True
from fastapi import APIRouter, UploadFile
from fastapi.responses import FileResponse, HTMLResponse
from fastapi_sso.sso.google import GoogleSSO
from starlette.requests import Request
from ..models import request as request_model, response as response_model
from ..models.database import User, Token
from ..exceptions.user import TokenNotFound, Forbidden
from ..exceptions.file import FileError, FileNotFound
from ..config import get_settings
from uuid import UUID, uuid4
from datetime import datetime, timedelta
import os, aiofiles

app=APIRouter()

settings=get_settings()
google_sso = GoogleSSO(settings.google_client, settings.google_secret, settings.sso_callback.replace("{service}","google"), use_state=False)

@app.post("/signup", response_model=response_model.User, responses={403: {"model": Forbidden}})
async def signup(user:request_model.User_signup):
    if await User.get_bymail(user.email) is not None:
        raise Forbidden("Password or other infomation is wrong.")
    user:User=await User.create(**user.dict())
    return response_model.User.from_orm(user)

@app.post("/signin", responses={404: {"model": Forbidden}, 403: {"model": Forbidden}}, response_model=response_model.User)
async def signin(user:request_model.User_signin):
    user_db:User=await User.get_bymail(user.email)
    if user_db is None:
        raise Forbidden("Password or other infomation is wrong.")
    elif user.password.get_secret_value() == user_db.password:
        token:Token=await Token.create(user_id=str(user_db.id), expired_in=datetime.utcnow()+timedelta(hours=1))
        resp_user=response_model.User.from_orm(user_db)
        resp_user.token = token.token
        return resp_user
    else:
        raise Forbidden("Password or other infomation is wrong.")

@app.post("/signout", responses={403: {"model": Forbidden}, 405: {"model": TokenNotFound}}, response_model=bool)
async def signout(user:request_model.User_signout):
    token:Token=await Token.get(user.token)
    if token is None:
        raise TokenNotFound(user_id=user.id, token=user.token)
    elif str(token.user_id) != str(user.id):
        raise Forbidden(description="Token is not yours.")
    try:
        await Token.delete(user.token)
    except:
        from traceback import format_exc
        print(format_exc())
        return False
    else:
        return True

@app.post("/update_token", responses={403: {"model": Forbidden}, 405: {"model": TokenNotFound}}, response_model=response_model.User)
async def update_token(token:request_model.Token):
    token_db:Token=await Token.get(token.token)
    if token_db is None:
        raise TokenNotFound(user_id=token.id, token=token.token)
    elif str(token_db.user_id) != str(token.id):
        raise Forbidden(description="Token is not yours.")
    elif token_db.expired_in < datetime.utcnow():
        try:
            await Token.delete(token.token)
        finally:
            raise Forbidden(description="Token was already expired.")
    else:
        await Token.delete(token.token)
        resp_user=response_model.User.from_orm(token_db.user)
        token_db:Token=await Token.create(user_id=str(token.id), expired_in=datetime.utcnow()+timedelta(hours=1))
        resp_user.token = token_db.token
        return resp_user

@app.get("/user/{id}/", response_model=response_model.User_withshops, responses={403: {"model": Forbidden}, 404: {"model": Forbidden}, 405: {"model": TokenNotFound}})
async def user(id:UUID, token:UUID=None):
    user:User=await User.get(id, include_shops=True)
    if user is None:
        raise Forbidden(description="Token is not yours.")
    resp_user=response_model.User_withshops(id=user.id, name=user.name, is_store=user.is_store, email=None, token=token)
    if token is not None:
        token_obj:Token=await Token.get(token)
        if token_obj is None:
            raise TokenNotFound(user_id=id, token=token)
        if str(token_obj.user_id) == str(user.id):
            resp_user.email=user.email
            resp_user.shops=[shop.id for shop in user.shops]
        else:
            raise Forbidden(description="Token is not yours.")
    return resp_user

@app.put("/user/{id}/", response_model=bool, responses={403: {"model": Forbidden}, 404: {"model": Forbidden}, 405: {"model": TokenNotFound}})
async def user(id:UUID, query:request_model.UserEdit):
    token=query.token
    user:User=await User.get(id)
    if user is None:
        raise Forbidden(description="Token is not yours.")
    token:Token=await Token.get(token)
    if token is None:
        raise TokenNotFound(user_id=id, token=token)
    elif str(token.user_id) != str(user.id):
        raise Forbidden(description="Token is not yours.")
    update_dict={}
    if query.newpassword is not None and query.oldpassword is not None:
        if query.oldpassword.get_secret_value() == user.password:
            update_dict.update(password=query.newpassword.get_secret_value())
        else:
            raise Forbidden("Wrong Password")
    if query.name is not None:
        update_dict.update(name=query.name)
    if query.email is not None:
        update_dict.update(email=query.email)
    if query.is_store is not None:
        update_dict.update(is_store=query.is_store)
    try:
        await User.update(id, **update_dict)
    except:
        from traceback import format_exc
        print(format_exc())
        return False
    else:
        return True

@app.delete("/user/{id}/", response_model=bool)
async def user(id:UUID, query:request_model.DeleteUser):
    user:User=await User.get(id)
    if user is None:
        raise Forbidden(description="Token is not yours.")
    token:Token=await Token.get(query.token)
    if token is None:
        raise TokenNotFound(user_id=id, token=query.token)
    elif str(token.user_id) != str(user.id):
        raise Forbidden(description="Token is not yours.")
    elif query.password.get_secret_value() != user.password:
        raise Forbidden(description="Wrong Password")
    try:
        await User.delete(id)
    except:
        from traceback import format_exc
        print(format_exc())
        return False
    else:
        return True

@app.get("/sso/{service}/")
async def sso(service:request_model.SSO_Services):
    if service.value == "google":
        return await google_sso.get_login_redirect()

@app.get("/sso/{service}/callback", response_class=HTMLResponse)
async def sso_callback(service:request_model.SSO_Services, request: Request):
    if service.value == "google":
        user=await google_sso.verify_and_process(request)
        user_db:User=await User.get_bymail(user.email)
        if user_db is None:
            user_db:User=await User.create(name=user.display_name, email=user.email, password=None)
        if user_db.password is None:
            token:Token=await Token.create(user_id=str(user_db.id), expired_in=datetime.utcnow()+timedelta(hours=1))
            return HTMLResponse(content=f"""
            <html><head><title>SSO</title></head><body>
            <script>
            sessionStorage["token"]="{str(token.token)}";\n
            sessionStorage["id"]="{str(user_db.id)}";\n
            location.href="/";
            </script></body></html>
            """)
        else:
            raise Forbidden("NOT SSO Account")
        

@app.put("/image/user/{user_id}/", response_model=bool)
async def set_usericon(user_id:UUID, token:UUID, image:UploadFile=None):
    await Token.check(user_id, token)
    user:User=await User.get(user_id)
    if user is None:
        raise Forbidden(user_id)
    if not image.content_type in ["image/png","image/jpeg"]:
        raise FileError("File type is not allowed.")
    if user.icon is not None:
        if os.path.exists(os.path.join(settings.image_storage, user.icon)):os.remove(os.path.join(settings.image_storage, user.icon))
    if image is None:
        icon=None
    else:
        size=0
        icon=str(uuid4())+os.path.splitext(image.filename)[1]
        async with aiofiles.open(os.path.join(settings.image_storage, icon), "wb") as icon_file:
            while content := await image.read(1024):
                size+=1
                if size==10240:
                    raise FileError("File is too large.")
                await icon_file.write(content)
    await User.update(user_id, icon=icon)
    return True

@app.get("/image/user/{user_id}/", response_class=FileResponse)
async def get_usericon(user_id:UUID, temp:str=None):
    user:User=await User.get(user_id)
    if user is None:
        raise Forbidden(description="Token is not yours.")
    if user.icon is None:
        raise FileNotFound(f"usericon for user {user_id} is not found")
    return FileResponse(os.path.join(settings.image_storage, user.icon))
from typing import List
from uuid import UUID, uuid4
from fastapi import APIRouter, UploadFile
from ..models import request as request_model, response as response_model
from ..models.database import Shop, Token
from ..exceptions.user import TokenNotFound, Forbidden
from ..exceptions.shop import ShopNotFound
from ..exceptions.file import FileError, FileNotFound
from ..config import get_settings
from fastapi.responses import FileResponse
import os
import aiofiles

app=APIRouter()

settings=get_settings()

@app.put("/shop/", response_model=response_model.Shop, responses={403: {"model": Forbidden}, 405: {"model": TokenNotFound}})
async def create_shop(req:request_model.CreateShop):
    token=await Token.check(req.user_id, req.token)
    if not token.user.is_store:
        raise Forbidden("You are not store acount.")
    req:dict=req.dict()
    req.pop("token")
    shop:Shop=await Shop.create(**req)
    return response_model.Shop.from_orm(shop)

@app.put("/shop/{shop_id}/", response_model=bool, responses={403: {"model": Forbidden}, 404: {"model": ShopNotFound}, 405: {"model": TokenNotFound}})
async def update_shop(req:request_model.EditShop, shop_id:UUID):
    await Token.check(req.user_id, req.token)
    shop:Shop=await Shop.get(shop_id)
    if shop is None:
        raise ShopNotFound(shop_id)
    elif str(shop.user_id)!=str(req.user_id):
        raise Forbidden("You don't have permission to edit this shop.")
    try:
        await Shop.update(shop_id, **{i:v for i, v in req.dict().items() if v is not None})
    except:
        from traceback import format_exc
        print(format_exc())
        return False
    else:
        return True

@app.get("/shop/{shop_id}/", response_model=response_model.Shop_withitems, responses={403: {"model": Forbidden}, 404: {"model": ShopNotFound}})
async def get_shop(shop_id:UUID):
    shop:Shop=await Shop.get(shop_id, include_items=True)
    if shop is None:
        raise ShopNotFound(shop_id)
    return response_model.Shop_withitems(id=shop.id, name=shop.name, description=shop.description, address=shop.address, items=[item.id for item in shop.items], coordinate=shop.coordinate)

@app.delete("/shop/{shop_id}/", response_model=bool, responses={403: {"model": Forbidden}, 404: {"model": ShopNotFound}, 405: {"model": TokenNotFound}})
async def delete_shop(req:request_model.DeleteShop, shop_id:UUID):
    await Token.check(req.user_id, req.token)
    shop:Shop=await Shop.get(shop_id)
    if shop is None:
        raise ShopNotFound(shop_id)
    elif str(shop.user_id)!=str(req.user_id):
        raise Forbidden("You don't have permission to edit this shop.")
    try:
        await Shop.delete(shop_id)
    except:
        from traceback import format_exc
        print(format_exc())
        return False
    else:
        return True

@app.put("/image/shop/{shop_id}/", response_model=bool)
async def set_shopimage(shop_id:UUID, user_id:UUID, token:UUID, image:UploadFile=None):
    await Token.check(user_id, token)
    shop:Shop=await Shop.get(shop_id)
    if shop is None:
        raise ShopNotFound(shop_id)
    if not image.content_type in ["image/png","image/jpeg"]:
        raise FileError("File type is not allowed.")
    elif str(shop.user_id)!=str(user_id):
        raise Forbidden("You don't have permission to edit this shop.")
    if shop.icon is not None:
        if os.path.exists(os.path.join(settings.image_storage, shop.icon)): os.remove(os.path.join(settings.image_storage, shop.icon))
    if image is None:
        icon=None
    else:
        size=0
        icon=str(uuid4())+os.path.splitext(image.filename)[1]
        async with aiofiles.open(os.path.join(settings.image_storage, icon), "wb") as icon_file:
            while content := await image.read(1024):
                size+=1
                if size==10240:
                    raise FileError("File is too large.")
                await icon_file.write(content)
    await Shop.update(shop_id, icon=icon)
    return True

@app.get("/image/shop/{shop_id}/", response_class=FileResponse)
async def get_shopimage(shop_id:UUID):
    shop:Shop=await Shop.get(shop_id)
    if shop is None:
        raise ShopNotFound(shop_id)
    if shop.icon is None:
        raise FileNotFound(f"shopimage for shop {shop_id} is not found")
    return FileResponse(os.path.join(settings.image_storage, shop.icon))

@app.put("/image/map/{shop_id}/", response_model=bool)
async def set_shopmap(shop_id:UUID, user_id:UUID, token:UUID, image:UploadFile=None):
    await Token.check(user_id, token)
    shop:Shop=await Shop.get(shop_id)
    if shop is None:
        raise ShopNotFound(shop_id)
    if not image.content_type in ["image/png","image/jpeg"]:
        raise FileError("File type is not allowed.")
    elif str(shop.user_id)!=str(user_id):
        raise Forbidden("You don't have permission to edit this shop.")
    if shop.map is not None:
        if os.path.exists(os.path.join(settings.image_storage, shop.map)):os.remove(os.path.join(settings.image_storage, shop.map))
    if image is None:
        icon=None
    else:
        size=0
        icon=str(uuid4())+os.path.splitext(image.filename)[1]
        async with aiofiles.open(os.path.join(settings.image_storage, icon), "wb") as icon_file:
            while content := await image.read(1024):
                size+=1
                if size==10240:
                    raise FileError("File is too large.")
                await icon_file.write(content)
    await Shop.update(shop_id, map=icon)
    return True

@app.get("/image/map/{shop_id}/", response_class=FileResponse)
async def get_shopmap(shop_id:UUID):
    shop:Shop=await Shop.get(shop_id)
    if shop is None:
        raise ShopNotFound(shop_id)
    if shop.map is None:
        raise FileNotFound(f"shopmap for shop {shop_id} is not found")
    return FileResponse(os.path.join(settings.image_storage, shop.map))

@app.get("/search/shop/", response_model=List[response_model.Shop])
async def search(address:str):
    return await Shop.search_byaddress(address)

@app.get("/search/shop/geojson", response_model=List[response_model.PointModelWithShop])
async def search(address:str):
    response=[]
    for shop in await Shop.search_byaddress(address):
        shop=response_model.Shop_withitems.from_orm(shop)
        response.append(response_model.PointModelWithShop(properties=shop, **shop.coordinate))
    return response